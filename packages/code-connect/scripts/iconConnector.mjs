/* eslint-disable no-console */
/**
 * iconConnector.mjs
 *
 * This script generates Figma connections for icons in the PatternFly React library.
 * It focuses only on creating the Figma connection file, not individual icon files.
 */
import fs from 'fs/promises';
import path from 'path';
import { existsSync } from 'fs';

// Simple logger implementation
const logger = {
  success: (msg) => console.log(`✅ ${msg}`),
  info: (msg) => console.log(`ℹ️ ${msg}`),
  warn: (msg) => console.warn(`⚠️ ${msg}`),
  error: (msg, err) => console.error(`❌ ${msg}`, err || '')
};

/**
 * Extract node ID from a Figma URL
 *
 * @param {string} url - Figma URL potentially containing a node ID
 * @returns {string|null} - Extracted node ID or null if not found
 */
function extractNodeId(url) {
  if (!url) {
    return null;
  }

  // Use regex to extract the node-id parameter from the URL
  const match = url.match(/node-id=([^&]+)/);
  return match ? match[1] : null;
}

/**
 * Standardize icon name format
 * Converts patterns like (far) to Far in icon names
 *
 * @param {string} name - Icon name to standardize
 * @returns {string} - Standardized icon name
 */
function standardizeIconName(name) {
  // Replace (far) with Far in icon names
  return name.replace(/\(far\)/i, 'Far');
}

/**
 * Generate Figma connections for icons
 */
async function generateIconConnections() {
  try {
    // Read the existing icons data
    let config;
    try {
      const configPath = path.resolve(process.cwd(), 'codeConnect/config.json');
      if (existsSync(configPath)) {
        const configContent = await fs.readFile(configPath, 'utf8');
        config = JSON.parse(configContent);
        logger.success('Loaded configuration from config.json');
      } else {
        throw new Error('Configuration file not found');
      }
    } catch (error) {
      logger.warn('Could not load config.json, using default configuration');
      config = {
        figmaBaseUrl:
          'https://www.figma.com/design/aEBBvq0J3EPXxHvv6WgDx9/PatternFly-6%3A-Components-Test?node-id=35205-247&m=dev',
        defaultNodeId: '1-196',
        iconsDataPath: '../data/iconsData.json',
        iconsFigmaDir: '../icons',
        figmaOutputFile: 'icons.figma.tsx',
        generatedIndexFile: 'index.ts'
      };
    }

    const iconsDataPath = config.iconsDataPath;
    const outputDir = config.iconsFigmaDir;
    let iconsData = [];

    try {
      const iconsDataContent = await fs.readFile(iconsDataPath, 'utf8');
      iconsData = JSON.parse(iconsDataContent);
      logger.success(`Loaded ${iconsData.length} icons from ${iconsDataPath}`);
    } catch (error) {
      logger.warn('Could not read icons data, using minimal configuration', {
        source: 'IconConnectionGenerator',
        context: { path: iconsDataPath, error: error.message }
      });
    }

    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });

    // Filter out problematic Icon Size entries
    const filteredIcons = iconsData.filter((icon) => icon && icon.reactName && !icon.reactName.startsWith('Icon Size'));

    logger.info(`Filtered out ${iconsData.length - filteredIcons.length} problematic icons`);

    // Create a Map to track unique icon exports and detect duplicates
    const iconMap = new Map();
    const duplicates = [];

    // Process icons to detect duplicates and standardize names
    for (const icon of filteredIcons) {
      // Standardize the icon name if it exists
      if (icon.reactName) {
        icon.reactName = standardizeIconName(icon.reactName);
      }

      if (iconMap.has(icon.reactName)) {
        duplicates.push(icon.reactName);
      } else {
        iconMap.set(icon.reactName, icon);
      }
    }

    if (duplicates.length > 0) {
      logger.warn(`Found ${duplicates.length} duplicate icons: ${duplicates.join(', ')}`);
    }

    // Get unique icons
    const uniqueIcons = Array.from(iconMap.values());
    const componentNames = uniqueIcons.map((icon) => icon.reactName).sort();

    // Generate figma.tsx file
    const importStatement = `import React from "react";
import {
  ${componentNames.join(',\n  ')}
} from "@patternfly/react-icons/dist/esm/icons";
import figma from "@figma/code-connect";`;

    const connectionContent = `
/**
 * -- This file was auto-generated by the figmaConnector script --
 * This file connects icon components to their corresponding Figma components.
 */

${uniqueIcons
  .map((icon) => {
    // Extract node ID from URL or use default
    const nodeId = icon.url ? extractNodeId(icon.url) || config.defaultNodeId : config.defaultNodeId;

    // Construct the full Figma URL with node ID
    const url = `${config.figmaBaseUrl}?node-id=${nodeId}&m=dev`;

    return `figma.connect(${icon.reactName}, "${url}", {
  props: {},
  example: (props) => <${icon.reactName} {...props} />
});`;
  })
  .join('\n\n')}
`;

    const fullContent = `${importStatement}\n${connectionContent}`;

    // Write output files
    const connectionFilePath = path.join(outputDir, config.figmaOutputFile);
    await fs.writeFile(connectionFilePath, fullContent, 'utf8');

    logger.success('Generated icon connections', {
      source: 'IconConnectionGenerator',
      context: {
        uniqueIconCount: uniqueIcons.length,
        outputPath: connectionFilePath
      }
    });

    // Generate index file
    const indexContent = uniqueIcons
      .filter((icon) => icon.fileName)
      .map((icon) => {
        // Standardize the fileName to match the reactName if needed
        const fileName = icon.fileName.replace(/\(far\)/i, 'Far');
        return `export { ${icon.reactName} } from './${fileName}';`;
      })
      .join('\n');

    const indexPath = path.join(outputDir, config.generatedIndexFile);
    await fs.writeFile(indexPath, indexContent);

    logger.success(`Generated index file at ${indexPath}`);

    return true;
  } catch (error) {
    logger.error('Error generating icon connections', error, {
      source: 'IconConnectionGenerator'
    });
    return false;
  }
}

// Run the script
generateIconConnections()
  .then((success) => {
    if (success) {
      logger.success('Figma icon connections generated successfully! 🎉');
      logger.info('To publish to Figma, run:');
      logger.info('  FIGMA_TOKEN=your_token npx figma connect publish');
    }
    process.exit(success ? 0 : 1);
  })
  .catch((error) => {
    logger.error('Unhandled error:', error);
    process.exit(1);
  });
